#!/bin/bash

BRANCH="$(git rev-parse --abbrev-ref HEAD)"
ROOT="$(git rev-parse --show-toplevel)"
CWD="$(pwd)"

cd "$ROOT"

[ "$(git status --porcelain)" ] && DIRTY=1 || DIRTY=
[ "$DIRTY" ] && git stash save -a -q
if [ "$BRANCH" != $SRC_BRANCH ]
then
    git checkout -q $SRC_BRANCH
fi
./configure
make -s gyb

TARGET="$1"
KEEP=Sources
PULL=
STATE=
for i in $(eval echo "{2..$#}")
do
    case "$i" in
    -k)
        STATE=KEEP
        ;;
    -p)
        STATE=PULL
        ;;
    -r)
        STATE=README
        ;;
    -R)
        STATE=README_TEXT
        ;;
    *)
        case "$STATE" in
        KEEP)
            KEEP="$KEEP '$i'"
            ;;
        PULL)
            PULL="$PULL '$i'"
            ;;
        README)
            cp "$i" README.md
            KEEP="$KEEP README.md"
            STATE=
            ;;
        README_TEXT)
            echo "$i" >README.md
            KEEP="$KEEP README.md"
            STATE=
            ;;
        *)
            continue
            ;;
        esac
        ;;
    esac
done

make -s "$TARGET"
echo "$KEEP" | xargs git add
git stash save -q
if [ -n "$(git rev-parse -q --verify $DEST_BRANCH)" ]
then
    git checkout -q $DEST_BRANCH
else
    git checkout -q --orphan $DEST_BRANCH
fi
git reset -q
git clean -dfxq
git stash pop -q

SRCS="$(git ls-tree -r --name-only $SRC_BRANCH Sources | sed '/\.gyb$/d')"
echo "$PULL" | xargs git checkout $SRC_BRANCH "$SRCS"

_generate

git commit -m "auto-generated commit by '$SELF_NAME' using $(git rev-parse $SRC_BRANCH)"

git checkout -q $BRANCH
git reset -q
git clean -dfxq
git checkout -q -- .
[ "$DIRTY" ] && git stash pop -q

cd "$CWD"
