#!/bin/bash

BRANCH="$(git rev-parse --abbrev-ref HEAD)"
ROOT="$(git rev-parse --show-toplevel)"
CWD="$(pwd)"

cd "$ROOT"

[ "$(git status --porcelain)" ] && DIRTY=1 || DIRTY=
[ "$DIRTY" ] && git stash save -a -q
if [ "$BRANCH" != $SRC_BRANCH ]
then
    git checkout -q $SRC_BRANCH
fi
./configure
make -s gyb

TARGET="$1"
KEEP=Sources
PULL=
SAVE=
STATE=
for arg in "${@:2}"
do
    case "$arg" in
    -k)
        STATE=KEEP
        ;;
    -p)
        STATE=PULL
        ;;
    -s)
        STATE=SAVE
        ;;
    -r)
        STATE=README
        ;;
    -R)
        STATE=README_TEXT
        ;;
    *)
        case "$STATE" in
        KEEP)
            KEEP="$KEEP '$arg'"
            ;;
        PULL)
            PULL="$PULL '$arg'"
            ;;
        SAVE)
            SAVE="$SAVE '$arg'"
            ;;
        README)
            cp "$arg" README.md
            KEEP="$KEEP README.md"
            STATE=
            ;;
        README_TEXT)
            echo "$arg" >README.md
            KEEP="$KEEP README.md"
            STATE=
            ;;
        *)
            continue
            ;;
        esac
        ;;
    esac
done

make -s "$TARGET" >/dev/null
echo "$KEEP"
echo "$KEEP" | xargs git add
git stash save -q
if [ -n "$(git rev-parse -q --verify $DEST_BRANCH)" ]
then
    git checkout -q $DEST_BRANCH
else
    git checkout -q --orphan $DEST_BRANCH
fi
git reset -q
git clean -dfxq
git stash pop -q

SRCS="$(git ls-tree -r --name-only $SRC_BRANCH Sources | sed '/\.gyb$/d')"
echo "$PULL" | xargs git checkout $SRC_BRANCH "$SRCS"

_generate

git commit -m "auto-generated commit using $(git rev-parse $SRC_BRANCH)" -m "generated by '$SELF_NAME'"

if [ -n "$SAVE" ]
then
    echo "$SAVE" | xargs git add
    git stash save -q
fi
git checkout -q $BRANCH
git reset -q
git clean -dfxq
git checkout -q -- .
if [ -n "$SAVE" ]
then
    git stash pop -q
    echo "$SAVE" | xargs git reset --
fi
[ "$DIRTY" ] && git stash pop -q

cd "$CWD"
